<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_lives</spriteName>
  <solid>-1</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>par_wall</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Basic Initialization
draw_set_font(fnt_lunch);
randomize();
depth = -y;
audio_play_sound(snd_livingloop,1,1);

//Your verticle speed
vsp = 0;
//Your horrozontal speed
hsp = 0;
//How fast the player moves
spd = 2.5;
//Game Controller
gamepad_set_axis_deadzone(0, 0.10);

//How fast the image index is gone through
image_speed = 10;

//Speed to be bounce away at from collision
//col_speed = 12*(60/room_speed);

//Can Attack by default
can_action = true;
can_secaction = true;

//Direction you are facing
facing = 0;
vface = 0;
hface = 0;

global.Paused = 0;

//type of wall you can go through
_myType = noone;


_lastRoom = rm_forest1;
_lastX = 768;
_lastY = 1008;

//secondary action alarm
alr_secact = -1;



</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Key Defaults
leftkey   = vk_left;
rightkey  = vk_right;
upkey     = vk_up;
downkey   = vk_down;
secattack = ord('X');
actionkey = ord('Z');
startkey  = vk_enter;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Bounce Back Initials
global.Hit = 0;
hit = 0;
_isHit = false;
_hitTimer = -1;
_maxHitTime = room_speed/2;
_maxHitDist = 16;
initialx = x;
initialy = y;
_sliding = false;
hitd = false;
hitu = false;
hitl = false;
hitr = false;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Health and life stats
//Health
_maxHp = 5;
_hp = _maxHp;
_hpX = 30;
_hpOff = 36;
_hpY = 30;
_alrHit = -1;

//Lives
_lives = 3;
_maxLives = 3;
_livX = _hpX;
_livY = _hpY;
_livOff = sprite_get_height(spr_lives) * 1.4;
alrDead = -1;
_fade = 0;
_dead = false;
_finDead = false;
global.Ghost = false;
_possesDist = 60;
_possesing = false;

_nearest = 0;
inside = 0


swinging = false;

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Sprite arrays
sprites = ds_list_create();
sprites[0] = spr_player_right;
sprites[1] = spr_player_left;
sprites[2] = spr_player_down;
sprites[3] = spr_player_up;
 
my_sprites = ds_list_create();
my_sprites[0] = spr_player_right;
my_sprites[1] = spr_player_left;
my_sprites[2] = spr_player_down;
my_sprites[3] = spr_player_up;

my_attacks = ds_list_create();
my_attacks[0] = spr_player_right;
my_attacks[1] = spr_player_left;
my_attacks[2] = spr_player_down;
my_attacks[3] = spr_player_up;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Basic Movement and collisions
//If gamepad is connected
if(gamepad_is_connected(0) &amp;&amp; !_isHit)
{
    //Setting the controls based off of the hardcoded buttons, needs to be fixed!!
    Tap_Jump = gamepad_button_check_pressed(0, gp_face1);
    Key_Jump = gamepad_button_check(0, gp_face1);
    Release_Jump = gamepad_button_check_released(0, gp_face1);
    
    //Checks if running or walking, sets the spd accordingly
    hsp = gamepad_axis_value(0, gp_axislh)*spd;
    vsp = gamepad_axis_value(0, gp_axislv)*spd;
}


//Keyboard
else if(!_isHit)
{
    //Get our inputs, currently only the defaults
    Key_Left    =   keyboard_check_direct(leftkey);
    Key_Right   =   keyboard_check_direct(rightkey);
    Key_Up     =   keyboard_check_direct(upkey);
    Key_Down   =   keyboard_check_direct(downkey);
    
    //Move up and down
    vsp = (Key_Down-Key_Up)*5;
        
    //Move left and right
    hsp = (Key_Right-Key_Left)*5;
}
 
//Collision check movement
//Check left and right
if(place_meeting(x+hsp,y,par_permeable))
{
  _moveCheckX = place_meeting(x+hsp,y,par_wall) &amp;&amp; !(place_meeting(x+hsp,y,par_permeable) &amp;&amp; /*object_get_name(*/instance_nearest(x,y,par_permeable).object_index == _myType);
}
else
{
  _moveCheckX = place_meeting(x+hsp,y,par_wall);
}

//Check up and down
if((place_meeting(x,y+vsp,par_permeable)))
{
  _moveCheckY =(place_meeting(x,y+vsp,par_wall) &amp;&amp; !(place_meeting(x,y+vsp,par_permeable) &amp;&amp; /*object_get_name(*/instance_nearest(x,y,par_permeable).object_index == _myType));
}
else
{
  _moveCheckY = place_meeting(x,y+vsp,par_wall);
}


//Horizontal Collision
if (_moveCheckX )//&amp;&amp; !(place_meeting(x+hsp,y,par_enemy) &amp;&amp; global.Hit))//MUST DEAL WITH SPIKES!
{
    hsp = 0; 
}
//Vertical collisions
if (_moveCheckY )//&amp;&amp; !(place_meeting(x,y+vsp,par_enemy) &amp;&amp; global.Hit))//MUST DEAL WITH SPIKES!
{
    vsp = 0; 
}

//Commit to movement
x += (hsp/room_speed*60);
y += (vsp/room_speed*60);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Facing code

var UD, LR;
UD = gamepad_axis_value(0, gp_axislv);
LR = gamepad_axis_value(0, gp_axislh);

Key_P_Left    =   keyboard_check_direct(leftkey);
Key_P_Right   =   keyboard_check_direct(rightkey);
Key_P_Down      =   keyboard_check_direct(upkey);
Key_P_Up    =   keyboard_check_direct(downkey);




if(Key_P_Right || LR &gt; 0)
{
  facing = 2;
  
}
if(Key_P_Left || LR &lt; 0)
{
  facing = 6;
  
}
if(Key_P_Up || UD &gt; 0)
{
  facing = 4;
 
}
if(Key_P_Down || UD &lt; 0)
{
  facing = 0;
  
}
if(vsp == 0 &amp;&amp; hsp == 0)// &amp;&amp; !swinging)
{
  image_speed = 0;
  image_index = 2;
}
else
{
  image_speed = .14;
}


switch(facing)
{
case 0: 
  if(_possesing)
  {
   sprite_index = sprites[3];
  }
  else
  {
    //if(!swinging)
    {  sprite_index = my_sprites[3];  }
  }
  break;
case 2: 
  if(_possesing)
  {
   sprite_index = sprites[0];
  }
  else
  {
    //if(!swinging)
    {  sprite_index = my_sprites[0];  }
  }
    break;
case 4: 
  if(_possesing  )
  {
   sprite_index = sprites[2];
  }
  else
  {
    //if(!swinging)
    {  sprite_index = my_sprites[2];  }
  }
break;
case 6:
if(_possesing )
  {
   sprite_index = sprites[1];
  }
  else
  {
    //if(!swinging)
    {  sprite_index = my_sprites[1];  }
  }
  break;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Actions

//Main attack, or action button
Key_Action = keyboard_check_pressed(actionkey) || gamepad_button_check_pressed(0,gp_face1);
Key_SecAction = keyboard_check_pressed(secattack) || gamepad_button_check_pressed(0,gp_face3);

if(Key_Action &amp;&amp; can_action)
{
  switch(irandom(3))
  {
    case 0:
      audio_play_sound(snd_swing1,1,0);
      break;
    case 1:
      audio_play_sound(snd_swing2,1,0);
      break;
    case 2:
      audio_play_sound(snd_swing3,1,0);
      break;
    case 3:
      audio_play_sound(snd_swing4,1,0);
      break;
  }
  can_action = false;
      iden = instance_create(x, y, obj_sword);
      iden.player_id = id;
      iden._enemy = par_enemy;
      swinging = true;
      image_speed = .14;
  switch(facing)
  {
    case 0: //up
      //if(!_possesing){sprite_index = my_attacks[3];} 
      iden.image_angle = 0;
      break;
    case 2:  //Right
      //if(!_possesing){sprite_index = my_attacks[0]; }
      iden.image_angle = 270;
      break;
    case 4:  //Down 
      //if(!_possesing){sprite_index = my_attacks[2]; }
      iden.image_angle = 180;
      break;
    case 6:   //Left
     // if(!_possesing){sprite_index = my_attacks[1];} 
      iden.image_angle = 90;
      break;
  }
  /*
  while(image_index == image_number-1)
  {
    swinging = false;
  }*/
}




//Secondary action
if(Key_SecAction)// &amp;&amp; can_action)
{
  if(global.Ghost)
  {
  inside =1
    _nearest = instance_nearest(x,y,par_enemy);
    if(distance_to_object(_nearest) &lt; _possesDist)
    {
      sprite_index = _nearest.sprite_index;
      _myType = _nearest._myType;
      _maxHp = _nearest._health;
      _hp = _maxHp;
      sprites = _nearest.sprites;
      with(_nearest)
      {
        instance_destroy();
      }
      _possesing = true;
    }
  }
  else if(can_secaction)
  {
    audio_play_sound(snd_FlintLock,1,0);
    can_secaction = false;
    iden = instance_create(x, y, obj_bullet);
    iden._enemy = par_enemy;
    iden.player_id = id;
    switch(facing)
  {
    case 0: //up
      iden.image_angle = 0;
      iden.dir = 0; 
      break;
    case 2:  //Right
      iden.image_angle = 270;
      iden.dir = 1;
      break;
    case 4:  //Down 
      iden.image_angle = 180;
      iden.dir = 2;
      break;
    case 6:   //Left
      iden.image_angle = 90;
      iden.dir = 3;
      break;
  }
  }
}

if(!can_secaction &amp;&amp; alr_secact == -1)
{
 alr_secact = room_speed*1.5;
}
if(alr_secact &gt; -1)
{
 alr_secact -= 1;
}

if(alr_secact == 0)
{
 can_secaction = true;
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Bounce Back
if(_isHit &amp;&amp; _sliding = false)
{
  _alrHit = room_speed*1.5;  //Second number is how many seconds before the player can be hurt by ANY ENEMY
  initialx = x;
  initialy = y;
  vsp = 0;
  hsp = 0;
  _sliding = true;
  testval = 1
}

//If you got hit and haven't slide far enough back
if(/*_isHit &amp;&amp; (distance_to_point(initialx,initialy) &lt; _maxHitDist &amp;&amp;*/ _hitTimer != -1)
{
  /*//These decide what speed to assign to you
  if(hitd)  //Down
  {
    vsp = spd;
  }
  if(hitu)  //Up
  {
    vsp = -spd;
  }
  if(hitr)  //Right
  {
    hsp = spd;
  }
  if(hitl)  //Left
  {
    hsp = -spd;
  }*/
}

//Reset variables
else if(_isHit)
{
  vsp = 0;
  hsp = 0;
  hitl = false;
  hitr = false;
  hitd = false;
  hitu = false;
  _isHit = false;
  _sliding = false;
  testval = 0
}

//How long you can slide
if(_hitTimer &gt; -1)
{
  _hitTimer -=1;
}


//Timer before you can be hit again
if(_alrHit &gt; -1)
{
  _alrHit -= 1;
}

if(_alrHit == 0)
{
  global.Hit = 0;
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Recieved Damage
if(hit &gt; 0)
{
  audio_play_sound(snd_AmeliaHit,1,0);
  (instance_create(x,y-sprite_height,obj_effect_damage)).text=string(hit);
  _hp += hit;
  _isHit = true;
  _hitTimer = _maxHitTime
  hit = 0;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Dying
if(_hp &lt;= 0 &amp;&amp; global.Ghost)
{
  _possesing = false;
  alrDead = room_speed*2;
}
else if(_hp &lt;= 0)
{
  audio_play_sound(snd_AmeliaDie,2,0);
  _hp = _maxHp;
  _lives -= 1;
  _dead = true;
  alrDead = room_speed;
  alrDead2 = room_speed*3;
}

if(_lives &gt; 0 &amp;&amp; !global.Ghost)
{

  if(alrDead &gt;-1)
  {
    //if(alrDead == room_speed*.9)
    //{
      room_goto(_lastRoom);
      x = _lastX;
      y = _lastY;
   // }
    alrDead--;
    _fade = -cos((alrDead*pi)/60)+1; 
  }
 if(alrDead == 0)
  {
    _dead = false;
  }
}
//Final Death
else if (!_finDead &amp;&amp; _dead)
{
  //Game over screen
  _finDead = true;
  _dead = false;
}

if(_finDead &amp;&amp; !global.Ghost)
{
    room_goto(rm_forest1);
    x = 768;
    y = 1008;
  audio_stop_sound(snd_livingloop);
  if(!audio_is_playing(snd_game_over))
  {
    audio_play_sound(snd_game_over,1,0);
  }
  if(alrDead2 &gt;-1)
  {
    alrDead2--;
    _fade = 1//-cos((alrDead*pi)/60)+1; 
  }
  if(alrDead2 == 0)
  {
    room_goto(rm_forest1);
    x = 768;
    y = 1008;
    global.Ghost = 1;
    sound_stop(snd_livingloop);
    audio_play_sound(snd_ghostloop,1,1);
    _hp = 0;
    _finDead = false;
  }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Displaying flash frames
/*
if(global.Hit)
{
  image_speed = .05;
}
else
{
  image_speed = 0;
  image_index = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Health and lives

for(i = 0; i &lt; _maxHp; i++)
{
  draw_sprite(spr_health,_hp &gt;= i+1, _hpX+_hpOff*i, _hpY);
}

draw_sprite(spr_lives,0,_livX, _livY + _livOff);

draw_text_colour(_livX, _livY+_livOff, "  x " + string(_lives),c_white,c_white,c_white,c_white,1);

//Lose all health -&gt; lose a life
if(_dead &amp;&amp; !_finDead)
{
  draw_set_colour(c_white);
  draw_sprite_stretched(spr_black,0,0,0,view_wview[0],view_hview[0]);
  draw_text_transformed(500, 500, "1 Life Lost!", 2.5, 2.5, 0);
}
//Die as in we loose all lives -&gt; Go Ghost
if(_finDead &amp;&amp; !global.Ghost){
  draw_set_colour(c_white);
  draw_sprite_stretched(spr_black,0,0,0,view_wview[0],view_hview[0]);
  draw_text_transformed(290, 210, "Game Over!", 2.5, 2.5, 0);
  draw_text_transformed(260, 275, "Out of lives", 2.5, 2.5, 0);
}
//Another if for if we actual finish the game - aka, game over



if(global.Switch3)
{
 instance_create(x,y,CONSOLE);
 // draw_text(100,100,"System Failure!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
}

/*if(_dead)
{
  draw_sprite_stretched_ext(spr_black,0,0,0,view_wview[0],view_hview[0],c_black,_fade);
}





</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="17">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>_hp -=15;
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
